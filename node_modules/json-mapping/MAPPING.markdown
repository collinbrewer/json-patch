-  App creates Todo
-  DataStack creates temporary ID
-  App commits Todo to local store WITHOUT temporary ID
-  Local store provides a new ID which is mapped back to the Todo, overriding the temporary ID
-  Sync!
-  Sync handler fetches changes to local store, results are referenced by local ID
-  Changes are pushed to remote store with the following conditions...
   -  if the remote store is master, the local nodes are pushed WITHOUT IDs, and the results are mapped back to the Todo, overriding the local ID
   -  alternatively, the ID collision can be avoided by rewiring as a separate key, for example: `clientID` in which case the remote store merges
   -  the local ID as `clientID` on the remote node, and the remote



## Remote Master / Local Slave

In this configuration, the remote is master and the authoritative source for object IDs.  The devil is in resolving the object IDs after the master store generates their IDs, particularly when objects have referenced other objects by the slave ID, which at the point of sync, is persisted in the local slave in potentially many locations.

In order to make this work we would need to either:

   1. Re-reference nodes by the master-assigned ID
   2. Store both references, so the local and remote references could be unified

The latter is more practical, and fairly simple using HRData's property mapping mechanism.  The ID generated by the remote store can be remapped locally as, for example, `serverID`.  This server ID will be stored in the local store alongside our original local ID, allowing us to uniquify the row by either ID or in a combined form of both IDs.

This becomes useful after an object is persisted remotely because the local store will have the reference provided by each store, thus creating a lookup table for references that can be used to resolve references between stores.

Given the following mappings:

```javascript
// Local Store
{
   "Todo": {
      "ID" : "localID"
   }
}

// Remote Store
{
   "Todo": {
      "ID" : null,
      "remoteID" : "objectId"
   }
}
```

The mapping causes communication flow to look like this:

| Local Store    | Local Store Map | Common (App Schema) | Remote Store Map     | Remote Store |
|:--------------:|:---------------:|:-------------------:|:--------------------:|:------------:|
| localID        | localID -> ID   | ID                  | ID -> (null)         | objectId     |
| remoteID       | <-              | remoteID            | remoteID <- objectId | objectId     |


This mapping allows us to avoid ID collisions and send the local Todo to the remote store:

| Todo (Local)  |
|---------------|
| localID: 1234 |

...which will first be mapped for the remote store as:

| Todo          |
|---------------|
| (null)        |



...where the remote store will respond with it's master id...

| Todo (Remote)  |
|----------------|
| objectId: ABCD |


...which we will mapped for the local store as:

| Todo           |
|----------------|
| objectId: ABCD |


...which will be merged with the local Todo, and store the data locally as:

| Todo (Local)   |
|----------------|
| localID: 1234  |
| remoteID: ABCD |


### ID Mapping
Now, subsequent calls will
